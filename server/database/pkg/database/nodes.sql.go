// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: nodes.sql

package database

import (
	"context"
	"net/netip"

	"github.com/jackc/pgx/v5/pgtype"
)

const listAllNodes = `-- name: ListAllNodes :many
SELECT n.ip_addr, n.source_id, n.version, s.last_execution
FROM nodes n
INNER JOIN sources s ON s.id = n.source_id
WHERE 1=1 
AND s.version < n.version 
AND n.ip_addr > $1
ORDER BY n.ip_addr
LIMIT $2
`

type ListAllNodesParams struct {
	IpAddr netip.Addr
	Limit  int32
}

type ListAllNodesRow struct {
	IpAddr        netip.Addr
	SourceID      int32
	Version       pgtype.Int8
	LastExecution pgtype.Timestamp
}

func (q *Queries) ListAllNodes(ctx context.Context, arg ListAllNodesParams) ([]ListAllNodesRow, error) {
	rows, err := q.db.Query(ctx, listAllNodes, arg.IpAddr, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAllNodesRow
	for rows.Next() {
		var i ListAllNodesRow
		if err := rows.Scan(
			&i.IpAddr,
			&i.SourceID,
			&i.Version,
			&i.LastExecution,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFilteredAllowlistNodes = `-- name: ListFilteredAllowlistNodes :many
SELECT n.ip_addr, n.source_id, n.version, s.last_execution
FROM nodes n
INNER JOIN sources s ON s.id = n.source_id
WHERE 1=1
AND s.version < n.version 
AND n.ip_addr > $1
AND n.ip_addr <<= ANY (
    SELECT a.cidr
    FROM allowlist_entry a 
    WHERE 1=1 
    AND a.list_id = $3
)
ORDER BY n.ip_addr
LIMIT $2
`

type ListFilteredAllowlistNodesParams struct {
	IpAddr netip.Addr
	Limit  int32
	ListID int32
}

type ListFilteredAllowlistNodesRow struct {
	IpAddr        netip.Addr
	SourceID      int32
	Version       pgtype.Int8
	LastExecution pgtype.Timestamp
}

func (q *Queries) ListFilteredAllowlistNodes(ctx context.Context, arg ListFilteredAllowlistNodesParams) ([]ListFilteredAllowlistNodesRow, error) {
	rows, err := q.db.Query(ctx, listFilteredAllowlistNodes, arg.IpAddr, arg.Limit, arg.ListID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListFilteredAllowlistNodesRow
	for rows.Next() {
		var i ListFilteredAllowlistNodesRow
		if err := rows.Scan(
			&i.IpAddr,
			&i.SourceID,
			&i.Version,
			&i.LastExecution,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNodesWithoutAllowlist = `-- name: ListNodesWithoutAllowlist :many
SELECT n.ip_addr, n.source_id, n.version, s.last_execution
FROM nodes n
INNER JOIN sources s ON s.id = n.source_id
WHERE 1=1
AND s.version < n.version 
AND n.ip_addr > $1
AND NOT n.ip_addr <<= ANY (
    SELECT a.cidr
    FROM allowlist_entry a 
    WHERE 1=1 
    AND a.list_id = $3
)
ORDER BY n.ip_addr
LIMIT $2
`

type ListNodesWithoutAllowlistParams struct {
	IpAddr netip.Addr
	Limit  int32
	ListID int32
}

type ListNodesWithoutAllowlistRow struct {
	IpAddr        netip.Addr
	SourceID      int32
	Version       pgtype.Int8
	LastExecution pgtype.Timestamp
}

func (q *Queries) ListNodesWithoutAllowlist(ctx context.Context, arg ListNodesWithoutAllowlistParams) ([]ListNodesWithoutAllowlistRow, error) {
	rows, err := q.db.Query(ctx, listNodesWithoutAllowlist, arg.IpAddr, arg.Limit, arg.ListID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListNodesWithoutAllowlistRow
	for rows.Next() {
		var i ListNodesWithoutAllowlistRow
		if err := rows.Scan(
			&i.IpAddr,
			&i.SourceID,
			&i.Version,
			&i.LastExecution,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSourcesNodes = `-- name: ListSourcesNodes :many
SELECT n.ip_addr, n.source_id, n.version, s.last_execution
FROM nodes n
INNER JOIN sources s ON s.id = n.source_id
WHERE 1=1 
AND s.version < n.version 
AND s.id = $3
AND n.ip_addr > $1
ORDER BY n.ip_addr
LIMIT $2
`

type ListSourcesNodesParams struct {
	IpAddr netip.Addr
	Limit  int32
	ID     int32
}

type ListSourcesNodesRow struct {
	IpAddr        netip.Addr
	SourceID      int32
	Version       pgtype.Int8
	LastExecution pgtype.Timestamp
}

func (q *Queries) ListSourcesNodes(ctx context.Context, arg ListSourcesNodesParams) ([]ListSourcesNodesRow, error) {
	rows, err := q.db.Query(ctx, listSourcesNodes, arg.IpAddr, arg.Limit, arg.ID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListSourcesNodesRow
	for rows.Next() {
		var i ListSourcesNodesRow
		if err := rows.Scan(
			&i.IpAddr,
			&i.SourceID,
			&i.Version,
			&i.LastExecution,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
