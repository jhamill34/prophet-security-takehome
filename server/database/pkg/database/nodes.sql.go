// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: nodes.sql

package database

import (
	"context"
	"net/netip"
)

const listAllNodes = `-- name: ListAllNodes :many
SELECT DISTINCT n.ip_addr
FROM nodes n
INNER JOIN sources s ON s.id = n.source_id
WHERE 1=1 
AND s.version < n.version 
AND n.ip_addr > $1
ORDER BY n.ip_addr
LIMIT $2
`

type ListAllNodesParams struct {
	IpAddr netip.Addr
	Limit  int32
}

func (q *Queries) ListAllNodes(ctx context.Context, arg ListAllNodesParams) ([]netip.Addr, error) {
	rows, err := q.db.Query(ctx, listAllNodes, arg.IpAddr, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []netip.Addr
	for rows.Next() {
		var ip_addr netip.Addr
		if err := rows.Scan(&ip_addr); err != nil {
			return nil, err
		}
		items = append(items, ip_addr)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFilteredAllowlistNodes = `-- name: ListFilteredAllowlistNodes :many
SELECT DISTINCT n.ip_addr
FROM nodes n
INNER JOIN sources s ON s.id = n.source_id
WHERE 1=1
AND s.version < n.version 
AND n.ip_addr > $1
AND NOT n.ip_addr <<= ANY (
    SELECT a.ip_addr
    FROM allowlist_entry a 
    WHERE 1=1 
    AND a.list_id = $3
)
ORDER BY n.ip_addr
LIMIT $2
`

type ListFilteredAllowlistNodesParams struct {
	IpAddr netip.Addr
	Limit  int32
	ListID int32
}

func (q *Queries) ListFilteredAllowlistNodes(ctx context.Context, arg ListFilteredAllowlistNodesParams) ([]netip.Addr, error) {
	rows, err := q.db.Query(ctx, listFilteredAllowlistNodes, arg.IpAddr, arg.Limit, arg.ListID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []netip.Addr
	for rows.Next() {
		var ip_addr netip.Addr
		if err := rows.Scan(&ip_addr); err != nil {
			return nil, err
		}
		items = append(items, ip_addr)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSourcesNodes = `-- name: ListSourcesNodes :many
SELECT DISTINCT n.ip_addr
FROM nodes n
INNER JOIN sources s ON s.id = n.source_id
WHERE 1=1 
AND s.version < n.version 
AND s.id = $3
AND n.ip_addr > $1
ORDER BY n.ip_addr
LIMIT $2
`

type ListSourcesNodesParams struct {
	IpAddr netip.Addr
	Limit  int32
	ID     int32
}

func (q *Queries) ListSourcesNodes(ctx context.Context, arg ListSourcesNodesParams) ([]netip.Addr, error) {
	rows, err := q.db.Query(ctx, listSourcesNodes, arg.IpAddr, arg.Limit, arg.ID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []netip.Addr
	for rows.Next() {
		var ip_addr netip.Addr
		if err := rows.Scan(&ip_addr); err != nil {
			return nil, err
		}
		items = append(items, ip_addr)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
