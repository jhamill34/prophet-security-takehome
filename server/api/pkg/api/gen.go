// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.3.0 DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/go-chi/chi/v5"
	"github.com/oapi-codegen/runtime"
	strictnethttp "github.com/oapi-codegen/runtime/strictmiddleware/nethttp"
)

// AddAllowlistEntryInput defines model for AddAllowlistEntryInput.
type AddAllowlistEntryInput struct {
	Cidr string `json:"cidr"`
}

// AllowlistEntry defines model for AllowlistEntry.
type AllowlistEntry struct {
	Id   int    `json:"id"`
	Name string `json:"name"`
}

// AllowlistEntryItem defines model for AllowlistEntryItem.
type AllowlistEntryItem struct {
	AllowlistId int    `json:"allowlist_id"`
	Cidr        string `json:"cidr"`
	Id          int    `json:"id"`
}

// CreateAllowlistInput defines model for CreateAllowlistInput.
type CreateAllowlistInput struct {
	Name string `json:"name"`
}

// CreateSourceEntryInput defines model for CreateSourceEntryInput.
type CreateSourceEntryInput struct {
	Name   string `json:"name"`
	Period string `json:"period"`
	Url    string `json:"url"`
}

// NodeEntry defines model for NodeEntry.
type NodeEntry struct {
	IpAddr  string            `json:"ip_addr"`
	Sources []NodeSourceEntry `json:"sources"`
}

// NodeSourceEntry defines model for NodeSourceEntry.
type NodeSourceEntry struct {
	LastExecution string `json:"last_execution"`
	SourceId      int    `json:"source_id"`
	Version       int    `json:"version"`
}

// PaginatedAllowlistEntry defines model for PaginatedAllowlistEntry.
type PaginatedAllowlistEntry struct {
	Cursor  string           `json:"cursor"`
	Data    []AllowlistEntry `json:"data"`
	HasMore bool             `json:"has_more"`
	Total   int              `json:"total"`
}

// PaginatedMetadata defines model for PaginatedMetadata.
type PaginatedMetadata struct {
	Cursor  string `json:"cursor"`
	HasMore bool   `json:"has_more"`
	Total   int    `json:"total"`
}

// PaginatedNodeEntry defines model for PaginatedNodeEntry.
type PaginatedNodeEntry struct {
	Cursor  string      `json:"cursor"`
	Data    []NodeEntry `json:"data"`
	HasMore bool        `json:"has_more"`
	Total   int         `json:"total"`
}

// PaginatedSourceEntry defines model for PaginatedSourceEntry.
type PaginatedSourceEntry struct {
	Cursor  string        `json:"cursor"`
	Data    []SourceEntry `json:"data"`
	HasMore bool          `json:"has_more"`
	Total   int           `json:"total"`
}

// SourceEntry defines model for SourceEntry.
type SourceEntry struct {
	Id            int    `json:"id"`
	LastExecution string `json:"last_execution"`
	Name          string `json:"name"`
	Period        string `json:"period"`
	Running       bool   `json:"running"`
	Url           string `json:"url"`
	Version       int    `json:"version"`
}

// ListAllAllowlistsParams defines parameters for ListAllAllowlists.
type ListAllAllowlistsParams struct {
	After *string `form:"after,omitempty" json:"after,omitempty"`
	Limit *int    `form:"limit,omitempty" json:"limit,omitempty"`
}

// ListAggregatedNodesParams defines parameters for ListAggregatedNodes.
type ListAggregatedNodesParams struct {
	AllowlistId *int    `form:"allowlistId,omitempty" json:"allowlistId,omitempty"`
	Invert      *bool   `form:"invert,omitempty" json:"invert,omitempty"`
	After       *string `form:"after,omitempty" json:"after,omitempty"`
	Limit       *int    `form:"limit,omitempty" json:"limit,omitempty"`
}

// ListSourcesParams defines parameters for ListSources.
type ListSourcesParams struct {
	After *string `form:"after,omitempty" json:"after,omitempty"`
	Limit *int    `form:"limit,omitempty" json:"limit,omitempty"`
}

// ListSourceNodesParams defines parameters for ListSourceNodes.
type ListSourceNodesParams struct {
	After *string `form:"after,omitempty" json:"after,omitempty"`
	Limit *int    `form:"limit,omitempty" json:"limit,omitempty"`
}

// CreateAllowlistJSONRequestBody defines body for CreateAllowlist for application/json ContentType.
type CreateAllowlistJSONRequestBody = CreateAllowlistInput

// AddToAllowlistJSONRequestBody defines body for AddToAllowlist for application/json ContentType.
type AddToAllowlistJSONRequestBody = AddAllowlistEntryInput

// CreateSourceJSONRequestBody defines body for CreateSource for application/json ContentType.
type CreateSourceJSONRequestBody = CreateSourceEntryInput

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /allowlist)
	ListAllAllowlists(w http.ResponseWriter, r *http.Request, params ListAllAllowlistsParams)

	// (POST /allowlist)
	CreateAllowlist(w http.ResponseWriter, r *http.Request)

	// (DELETE /allowlist/{id})
	DeleteAllowList(w http.ResponseWriter, r *http.Request, id int)

	// (GET /allowlist/{id}/entry)
	ListAllowlistEntries(w http.ResponseWriter, r *http.Request, id int)

	// (POST /allowlist/{id}/entry)
	AddToAllowlist(w http.ResponseWriter, r *http.Request, id int)

	// (DELETE /allowlist/{id}/entry/{entryId})
	RemoveFromAllowlist(w http.ResponseWriter, r *http.Request, id int, entryId int)

	// (GET /nodes)
	ListAggregatedNodes(w http.ResponseWriter, r *http.Request, params ListAggregatedNodesParams)

	// (GET /sources)
	ListSources(w http.ResponseWriter, r *http.Request, params ListSourcesParams)

	// (POST /sources)
	CreateSource(w http.ResponseWriter, r *http.Request)

	// (GET /sources/{id})
	ListSourceNodes(w http.ResponseWriter, r *http.Request, id int, params ListSourceNodesParams)

	// (POST /sources/{id}/start)
	StartSource(w http.ResponseWriter, r *http.Request, id int)

	// (POST /sources/{id}/stop)
	StopSource(w http.ResponseWriter, r *http.Request, id int)
}

// Unimplemented server implementation that returns http.StatusNotImplemented for each endpoint.

type Unimplemented struct{}

// (GET /allowlist)
func (_ Unimplemented) ListAllAllowlists(w http.ResponseWriter, r *http.Request, params ListAllAllowlistsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (POST /allowlist)
func (_ Unimplemented) CreateAllowlist(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (DELETE /allowlist/{id})
func (_ Unimplemented) DeleteAllowList(w http.ResponseWriter, r *http.Request, id int) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (GET /allowlist/{id}/entry)
func (_ Unimplemented) ListAllowlistEntries(w http.ResponseWriter, r *http.Request, id int) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (POST /allowlist/{id}/entry)
func (_ Unimplemented) AddToAllowlist(w http.ResponseWriter, r *http.Request, id int) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (DELETE /allowlist/{id}/entry/{entryId})
func (_ Unimplemented) RemoveFromAllowlist(w http.ResponseWriter, r *http.Request, id int, entryId int) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (GET /nodes)
func (_ Unimplemented) ListAggregatedNodes(w http.ResponseWriter, r *http.Request, params ListAggregatedNodesParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (GET /sources)
func (_ Unimplemented) ListSources(w http.ResponseWriter, r *http.Request, params ListSourcesParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (POST /sources)
func (_ Unimplemented) CreateSource(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (GET /sources/{id})
func (_ Unimplemented) ListSourceNodes(w http.ResponseWriter, r *http.Request, id int, params ListSourceNodesParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (POST /sources/{id}/start)
func (_ Unimplemented) StartSource(w http.ResponseWriter, r *http.Request, id int) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (POST /sources/{id}/stop)
func (_ Unimplemented) StopSource(w http.ResponseWriter, r *http.Request, id int) {
	w.WriteHeader(http.StatusNotImplemented)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// ListAllAllowlists operation middleware
func (siw *ServerInterfaceWrapper) ListAllAllowlists(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params ListAllAllowlistsParams

	// ------------- Optional query parameter "after" -------------

	err = runtime.BindQueryParameter("form", true, false, "after", r.URL.Query(), &params.After)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "after", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListAllAllowlists(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// CreateAllowlist operation middleware
func (siw *ServerInterfaceWrapper) CreateAllowlist(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateAllowlist(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// DeleteAllowList operation middleware
func (siw *ServerInterfaceWrapper) DeleteAllowList(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithOptions("simple", "id", chi.URLParam(r, "id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteAllowList(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// ListAllowlistEntries operation middleware
func (siw *ServerInterfaceWrapper) ListAllowlistEntries(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithOptions("simple", "id", chi.URLParam(r, "id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListAllowlistEntries(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// AddToAllowlist operation middleware
func (siw *ServerInterfaceWrapper) AddToAllowlist(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithOptions("simple", "id", chi.URLParam(r, "id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AddToAllowlist(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// RemoveFromAllowlist operation middleware
func (siw *ServerInterfaceWrapper) RemoveFromAllowlist(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithOptions("simple", "id", chi.URLParam(r, "id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// ------------- Path parameter "entryId" -------------
	var entryId int

	err = runtime.BindStyledParameterWithOptions("simple", "entryId", chi.URLParam(r, "entryId"), &entryId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "entryId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RemoveFromAllowlist(w, r, id, entryId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// ListAggregatedNodes operation middleware
func (siw *ServerInterfaceWrapper) ListAggregatedNodes(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params ListAggregatedNodesParams

	// ------------- Optional query parameter "allowlistId" -------------

	err = runtime.BindQueryParameter("form", true, false, "allowlistId", r.URL.Query(), &params.AllowlistId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "allowlistId", Err: err})
		return
	}

	// ------------- Optional query parameter "invert" -------------

	err = runtime.BindQueryParameter("form", true, false, "invert", r.URL.Query(), &params.Invert)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "invert", Err: err})
		return
	}

	// ------------- Optional query parameter "after" -------------

	err = runtime.BindQueryParameter("form", true, false, "after", r.URL.Query(), &params.After)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "after", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListAggregatedNodes(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// ListSources operation middleware
func (siw *ServerInterfaceWrapper) ListSources(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params ListSourcesParams

	// ------------- Optional query parameter "after" -------------

	err = runtime.BindQueryParameter("form", true, false, "after", r.URL.Query(), &params.After)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "after", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListSources(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// CreateSource operation middleware
func (siw *ServerInterfaceWrapper) CreateSource(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateSource(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// ListSourceNodes operation middleware
func (siw *ServerInterfaceWrapper) ListSourceNodes(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithOptions("simple", "id", chi.URLParam(r, "id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params ListSourceNodesParams

	// ------------- Optional query parameter "after" -------------

	err = runtime.BindQueryParameter("form", true, false, "after", r.URL.Query(), &params.After)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "after", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListSourceNodes(w, r, id, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// StartSource operation middleware
func (siw *ServerInterfaceWrapper) StartSource(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithOptions("simple", "id", chi.URLParam(r, "id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.StartSource(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// StopSource operation middleware
func (siw *ServerInterfaceWrapper) StopSource(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithOptions("simple", "id", chi.URLParam(r, "id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.StopSource(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL          string
	BaseRouter       chi.Router
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/allowlist", wrapper.ListAllAllowlists)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/allowlist", wrapper.CreateAllowlist)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/allowlist/{id}", wrapper.DeleteAllowList)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/allowlist/{id}/entry", wrapper.ListAllowlistEntries)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/allowlist/{id}/entry", wrapper.AddToAllowlist)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/allowlist/{id}/entry/{entryId}", wrapper.RemoveFromAllowlist)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/nodes", wrapper.ListAggregatedNodes)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/sources", wrapper.ListSources)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/sources", wrapper.CreateSource)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/sources/{id}", wrapper.ListSourceNodes)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/sources/{id}/start", wrapper.StartSource)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/sources/{id}/stop", wrapper.StopSource)
	})

	return r
}

type ListAllAllowlistsRequestObject struct {
	Params ListAllAllowlistsParams
}

type ListAllAllowlistsResponseObject interface {
	VisitListAllAllowlistsResponse(w http.ResponseWriter) error
}

type ListAllAllowlists200JSONResponse PaginatedAllowlistEntry

func (response ListAllAllowlists200JSONResponse) VisitListAllAllowlistsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type CreateAllowlistRequestObject struct {
	Body *CreateAllowlistJSONRequestBody
}

type CreateAllowlistResponseObject interface {
	VisitCreateAllowlistResponse(w http.ResponseWriter) error
}

type CreateAllowlist201JSONResponse AllowlistEntry

func (response CreateAllowlist201JSONResponse) VisitCreateAllowlistResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)

	return json.NewEncoder(w).Encode(response)
}

type DeleteAllowListRequestObject struct {
	Id int `json:"id"`
}

type DeleteAllowListResponseObject interface {
	VisitDeleteAllowListResponse(w http.ResponseWriter) error
}

type DeleteAllowList204Response struct {
}

func (response DeleteAllowList204Response) VisitDeleteAllowListResponse(w http.ResponseWriter) error {
	w.WriteHeader(204)
	return nil
}

type ListAllowlistEntriesRequestObject struct {
	Id int `json:"id"`
}

type ListAllowlistEntriesResponseObject interface {
	VisitListAllowlistEntriesResponse(w http.ResponseWriter) error
}

type ListAllowlistEntries200JSONResponse []AllowlistEntryItem

func (response ListAllowlistEntries200JSONResponse) VisitListAllowlistEntriesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type AddToAllowlistRequestObject struct {
	Id   int `json:"id"`
	Body *AddToAllowlistJSONRequestBody
}

type AddToAllowlistResponseObject interface {
	VisitAddToAllowlistResponse(w http.ResponseWriter) error
}

type AddToAllowlist201JSONResponse AllowlistEntryItem

func (response AddToAllowlist201JSONResponse) VisitAddToAllowlistResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)

	return json.NewEncoder(w).Encode(response)
}

type RemoveFromAllowlistRequestObject struct {
	Id      int `json:"id"`
	EntryId int `json:"entryId"`
}

type RemoveFromAllowlistResponseObject interface {
	VisitRemoveFromAllowlistResponse(w http.ResponseWriter) error
}

type RemoveFromAllowlist204Response struct {
}

func (response RemoveFromAllowlist204Response) VisitRemoveFromAllowlistResponse(w http.ResponseWriter) error {
	w.WriteHeader(204)
	return nil
}

type ListAggregatedNodesRequestObject struct {
	Params ListAggregatedNodesParams
}

type ListAggregatedNodesResponseObject interface {
	VisitListAggregatedNodesResponse(w http.ResponseWriter) error
}

type ListAggregatedNodes200JSONResponse PaginatedNodeEntry

func (response ListAggregatedNodes200JSONResponse) VisitListAggregatedNodesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type ListSourcesRequestObject struct {
	Params ListSourcesParams
}

type ListSourcesResponseObject interface {
	VisitListSourcesResponse(w http.ResponseWriter) error
}

type ListSources200JSONResponse PaginatedSourceEntry

func (response ListSources200JSONResponse) VisitListSourcesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type CreateSourceRequestObject struct {
	Body *CreateSourceJSONRequestBody
}

type CreateSourceResponseObject interface {
	VisitCreateSourceResponse(w http.ResponseWriter) error
}

type CreateSource201JSONResponse SourceEntry

func (response CreateSource201JSONResponse) VisitCreateSourceResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)

	return json.NewEncoder(w).Encode(response)
}

type ListSourceNodesRequestObject struct {
	Id     int `json:"id"`
	Params ListSourceNodesParams
}

type ListSourceNodesResponseObject interface {
	VisitListSourceNodesResponse(w http.ResponseWriter) error
}

type ListSourceNodes200JSONResponse PaginatedNodeEntry

func (response ListSourceNodes200JSONResponse) VisitListSourceNodesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type StartSourceRequestObject struct {
	Id int `json:"id"`
}

type StartSourceResponseObject interface {
	VisitStartSourceResponse(w http.ResponseWriter) error
}

type StartSource204Response struct {
}

func (response StartSource204Response) VisitStartSourceResponse(w http.ResponseWriter) error {
	w.WriteHeader(204)
	return nil
}

type StopSourceRequestObject struct {
	Id int `json:"id"`
}

type StopSourceResponseObject interface {
	VisitStopSourceResponse(w http.ResponseWriter) error
}

type StopSource204Response struct {
}

func (response StopSource204Response) VisitStopSourceResponse(w http.ResponseWriter) error {
	w.WriteHeader(204)
	return nil
}

// StrictServerInterface represents all server handlers.
type StrictServerInterface interface {

	// (GET /allowlist)
	ListAllAllowlists(ctx context.Context, request ListAllAllowlistsRequestObject) (ListAllAllowlistsResponseObject, error)

	// (POST /allowlist)
	CreateAllowlist(ctx context.Context, request CreateAllowlistRequestObject) (CreateAllowlistResponseObject, error)

	// (DELETE /allowlist/{id})
	DeleteAllowList(ctx context.Context, request DeleteAllowListRequestObject) (DeleteAllowListResponseObject, error)

	// (GET /allowlist/{id}/entry)
	ListAllowlistEntries(ctx context.Context, request ListAllowlistEntriesRequestObject) (ListAllowlistEntriesResponseObject, error)

	// (POST /allowlist/{id}/entry)
	AddToAllowlist(ctx context.Context, request AddToAllowlistRequestObject) (AddToAllowlistResponseObject, error)

	// (DELETE /allowlist/{id}/entry/{entryId})
	RemoveFromAllowlist(ctx context.Context, request RemoveFromAllowlistRequestObject) (RemoveFromAllowlistResponseObject, error)

	// (GET /nodes)
	ListAggregatedNodes(ctx context.Context, request ListAggregatedNodesRequestObject) (ListAggregatedNodesResponseObject, error)

	// (GET /sources)
	ListSources(ctx context.Context, request ListSourcesRequestObject) (ListSourcesResponseObject, error)

	// (POST /sources)
	CreateSource(ctx context.Context, request CreateSourceRequestObject) (CreateSourceResponseObject, error)

	// (GET /sources/{id})
	ListSourceNodes(ctx context.Context, request ListSourceNodesRequestObject) (ListSourceNodesResponseObject, error)

	// (POST /sources/{id}/start)
	StartSource(ctx context.Context, request StartSourceRequestObject) (StartSourceResponseObject, error)

	// (POST /sources/{id}/stop)
	StopSource(ctx context.Context, request StopSourceRequestObject) (StopSourceResponseObject, error)
}

type StrictHandlerFunc = strictnethttp.StrictHTTPHandlerFunc
type StrictMiddlewareFunc = strictnethttp.StrictHTTPMiddlewareFunc

type StrictHTTPServerOptions struct {
	RequestErrorHandlerFunc  func(w http.ResponseWriter, r *http.Request, err error)
	ResponseErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

func NewStrictHandler(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares, options: StrictHTTPServerOptions{
		RequestErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		},
		ResponseErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusInternalServerError)
		},
	}}
}

func NewStrictHandlerWithOptions(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc, options StrictHTTPServerOptions) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares, options: options}
}

type strictHandler struct {
	ssi         StrictServerInterface
	middlewares []StrictMiddlewareFunc
	options     StrictHTTPServerOptions
}

// ListAllAllowlists operation middleware
func (sh *strictHandler) ListAllAllowlists(w http.ResponseWriter, r *http.Request, params ListAllAllowlistsParams) {
	var request ListAllAllowlistsRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.ListAllAllowlists(ctx, request.(ListAllAllowlistsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ListAllAllowlists")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(ListAllAllowlistsResponseObject); ok {
		if err := validResponse.VisitListAllAllowlistsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// CreateAllowlist operation middleware
func (sh *strictHandler) CreateAllowlist(w http.ResponseWriter, r *http.Request) {
	var request CreateAllowlistRequestObject

	var body CreateAllowlistJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.CreateAllowlist(ctx, request.(CreateAllowlistRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "CreateAllowlist")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(CreateAllowlistResponseObject); ok {
		if err := validResponse.VisitCreateAllowlistResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// DeleteAllowList operation middleware
func (sh *strictHandler) DeleteAllowList(w http.ResponseWriter, r *http.Request, id int) {
	var request DeleteAllowListRequestObject

	request.Id = id

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.DeleteAllowList(ctx, request.(DeleteAllowListRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "DeleteAllowList")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(DeleteAllowListResponseObject); ok {
		if err := validResponse.VisitDeleteAllowListResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// ListAllowlistEntries operation middleware
func (sh *strictHandler) ListAllowlistEntries(w http.ResponseWriter, r *http.Request, id int) {
	var request ListAllowlistEntriesRequestObject

	request.Id = id

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.ListAllowlistEntries(ctx, request.(ListAllowlistEntriesRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ListAllowlistEntries")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(ListAllowlistEntriesResponseObject); ok {
		if err := validResponse.VisitListAllowlistEntriesResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// AddToAllowlist operation middleware
func (sh *strictHandler) AddToAllowlist(w http.ResponseWriter, r *http.Request, id int) {
	var request AddToAllowlistRequestObject

	request.Id = id

	var body AddToAllowlistJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.AddToAllowlist(ctx, request.(AddToAllowlistRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "AddToAllowlist")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(AddToAllowlistResponseObject); ok {
		if err := validResponse.VisitAddToAllowlistResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// RemoveFromAllowlist operation middleware
func (sh *strictHandler) RemoveFromAllowlist(w http.ResponseWriter, r *http.Request, id int, entryId int) {
	var request RemoveFromAllowlistRequestObject

	request.Id = id
	request.EntryId = entryId

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.RemoveFromAllowlist(ctx, request.(RemoveFromAllowlistRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "RemoveFromAllowlist")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(RemoveFromAllowlistResponseObject); ok {
		if err := validResponse.VisitRemoveFromAllowlistResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// ListAggregatedNodes operation middleware
func (sh *strictHandler) ListAggregatedNodes(w http.ResponseWriter, r *http.Request, params ListAggregatedNodesParams) {
	var request ListAggregatedNodesRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.ListAggregatedNodes(ctx, request.(ListAggregatedNodesRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ListAggregatedNodes")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(ListAggregatedNodesResponseObject); ok {
		if err := validResponse.VisitListAggregatedNodesResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// ListSources operation middleware
func (sh *strictHandler) ListSources(w http.ResponseWriter, r *http.Request, params ListSourcesParams) {
	var request ListSourcesRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.ListSources(ctx, request.(ListSourcesRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ListSources")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(ListSourcesResponseObject); ok {
		if err := validResponse.VisitListSourcesResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// CreateSource operation middleware
func (sh *strictHandler) CreateSource(w http.ResponseWriter, r *http.Request) {
	var request CreateSourceRequestObject

	var body CreateSourceJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.CreateSource(ctx, request.(CreateSourceRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "CreateSource")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(CreateSourceResponseObject); ok {
		if err := validResponse.VisitCreateSourceResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// ListSourceNodes operation middleware
func (sh *strictHandler) ListSourceNodes(w http.ResponseWriter, r *http.Request, id int, params ListSourceNodesParams) {
	var request ListSourceNodesRequestObject

	request.Id = id
	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.ListSourceNodes(ctx, request.(ListSourceNodesRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ListSourceNodes")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(ListSourceNodesResponseObject); ok {
		if err := validResponse.VisitListSourceNodesResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// StartSource operation middleware
func (sh *strictHandler) StartSource(w http.ResponseWriter, r *http.Request, id int) {
	var request StartSourceRequestObject

	request.Id = id

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.StartSource(ctx, request.(StartSourceRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "StartSource")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(StartSourceResponseObject); ok {
		if err := validResponse.VisitStartSourceResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// StopSource operation middleware
func (sh *strictHandler) StopSource(w http.ResponseWriter, r *http.Request, id int) {
	var request StopSourceRequestObject

	request.Id = id

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.StopSource(ctx, request.(StopSourceRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "StopSource")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(StopSourceResponseObject); ok {
		if err := validResponse.VisitStopSourceResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+RYTY/bNhP+Kwu+71FZOXVPurlfwKJpG9Q5FAgWC0Yc20wpkiFH2xqG/ntB6tuibMnr",
	"3W6Rk2WJM5xn5nmGIx1IqjKtJEi0JDkQm+4go/5yxdhKCPWX4BZ/lGj2d1Ln6J5QxjhyJal4b5QGgxws",
	"STZUWIiI7tw6kJQz435xr4EkxKLhckuKIiIGvuTcACPJx3LVfVSvUp8+Q4qkiEg/gJl7c9bZmUuELRjn",
	"VNIMzsfEGamWng/sDiGbGRytHTyMhTmSumgEVyh87yLq7xVC870BitBguqTQ05I6ms8ygrXKTQoXk20k",
	"hohoMFyx4KPciIlhl2sbZyEUvyoGFzFVP1A2Um3rc1IuQ8j8xf8NbEhC/he34o0r5cYuhk4enYvKJzWG",
	"7odEqfZudxpD1vU6D5+gFh/gb0hzZ3AC5qgYHsHYvukY8VtHrVV0HEEI4nu65ZIisEDTEeK3DUk+ns58",
	"4+AXQMooUlJEs9LkbabW+SjKc2X2voew77vAm7hn9vjcWBUm747ah0yZrio/KSWASh+wQiomlLTaoDbo",
	"uD1Zx74aX2EJ2wCvUb1jeb5CwHP60gnIlzeisfYyoUFdcriYXEp3GWR/+OSZ0+raEeXobBoA6rbCOqhh",
	"bl0bhjQ3HPdrV7FqUtH8Z/CJ5pIkZAeUgak3Tsgfb1aav3Er2oKWFoVzyOVGeSgchXvmSrQDvFlXG918",
	"oH/CTmVws9K8E2dCFrdvbxcuIUqDpJqThCxvF7cLB5PizscWN6ON+7cF/+MKTh3sO0YS8o5bXAnRtEvr",
	"7Q3NAMFYLxCP60sOZt/Cohv0KEvqBkeEsKHgGceQYVvFe1dGq5W0ZYa/WSx8H1USQZZDj9aCpx5E/NmW",
	"ZGgdThL08fngisHApobrkuPEFxzp1iWhnRGJU5hWNpDKozGRlGwEi98ptr8aguAwWvS5jyaHYpDFt1eL",
	"4QnJK6IOK+MDZ4VvkyAAYZjSH/x9v927OqU9TN+W1lPrFiC2E0tLT98z+ok8zdUhnhjqzntKcG3+XO99",
	"IuMvmIj8O9nwkJmlgutnc0xaK8Y+qOdW1sgb/b+qrbJMT9JXycf44H/uTuvtd8jUI/xkVNZP9qvSXBT0",
	"UsG7QL5SsRLauF63WwPbemieekQ2LZqRSXiO7Ll8BBM8Kpspacz0P386d0b/M9x3xato3/kUMFrJdbXm",
	"6xhyei8UZxLZfN44M9+UPp91uBl853rhFnxZ2joUbOaaMzyc002+Hkn3mPg8E1u3TrFFajzKFxxo1m7P",
	"jpRmHbDjnIstKv3iUJS+AhL/dm0e64j96z/ZIeokjoVKqdgpi8lyuVwSF0vlof6qXZ4DTgPHp2/3Zr1d",
	"cV/8EwAA//8yQJps2hkAAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
